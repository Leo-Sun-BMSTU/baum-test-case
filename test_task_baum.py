# -*- coding: utf-8 -*-
"""Test_task_BAUM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WWxYlyUTjQSDjXEE2IsWfQFjr3lQ-CMy
"""

# Commented out IPython magic to ensure Python compatibility.
import sys
import warnings
warnings.filterwarnings('ignore')
from tqdm import tqdm

import pandas as pd
import numpy as np
from sklearn.metrics import mean_absolute_error, mean_squared_error

import statsmodels.formula.api as smf
import statsmodels.tsa.api as smt
import statsmodels.api as sm
import scipy.stats as scs
from scipy.optimize import minimize

# %matplotlib inline
import matplotlib.pyplot as plt
import seaborn; seaborn.set()

data_path = '/content/drive/MyDrive/BAUM/Временной ряд.xlsx'
data = pd.read_excel(data_path, header=1, index_col='Data')
data.head() # поправить названия колонок

data.info()

plt.figure(figsize=(20, 6))
plt.plot(data[['Y5402 ']]);

def plotMovingAverage(series: pd.Series, n: int) -> None:

    """
    Plot creating function

    series - pandas Series with timeseries
    n - rolling window size, n=1 - 1 hour
    """

    rolling_mean = series.rolling(window=n).mean()

    plt.figure(figsize=(15,5))
    plt.title("Moving average\n window size = {}".format(n))
    plt.plot(rolling_mean, "g", label="Rolling mean trend")

    plt.plot(series[n:], label="Actual values")
    plt.legend(loc="upper left")
    plt.grid(True)

plotMovingAverage(data['Y5402 '], 24)

"""# Feature engineering"""

time_series = data[['Y5402 ']]
time_series.columns = ['y']

time_series['hour'] = time_series.index.hour
time_series['weekday'] = time_series.index.weekday
time_series['is_weekend'] = time_series.index.weekday.isin([5, 6]).astype(int)
time_series

train_set, test_set= np.split(time_series, [int(0.85 *len(data))])

def agg_feature_create(data, cat_feature, real_feature, agg_func: str):
    """
    Возвращает словарь, где ключами являются уникальные категории признака cat_feature, 
    а значениями - средние по real_feature
    """
    if agg_func == 'mean':
        return dict(data.groupby(cat_feature)[real_feature].mean())
    if agg_func == 'max':
        return dict(data.groupby(cat_feature)[real_feature].max())
    if agg_func == 'min':
        return dict(data.groupby(cat_feature)[real_feature].min())
    if agg_func == 'median':
        return dict(data.groupby(cat_feature)[real_feature].median())

for agg_func in ('mean', 'max', 'min', 'median'):
     new_col_value_dict = agg_feature_create(
         train_set, 'weekday', 'y', agg_func=agg_func
         )
     train_set[f'weekday_{agg_func}'] = train_set.weekday.apply(
         lambda row: new_col_value_dict.get(row)
         )

for agg_func in ('mean', 'max', 'min', 'median'):
     new_col_value_dict = agg_feature_create(
         test_set, 'weekday', 'y', agg_func=agg_func
         )
     test_set[f'weekday_{agg_func}'] = test_set.weekday.apply(
         lambda row: new_col_value_dict.get(row)
         )

train_set = pd.get_dummies(train_set, columns=['weekday'])
test_set = pd.get_dummies(test_set, columns=['weekday'])

train_set['rolling_mean_24'] = train_set.y.rolling(window=24).mean().fillna(train_set.y.head(23).mean())

test_set['rolling_mean_24'] = test_set.y.rolling(window=24).mean().fillna(test_set.y.head(23).mean())

from sklearn.preprocessing import StandardScaler

scaler = StandardScaler().fit(train_set.hour.values.reshape(-1, 1))
train_set.hour = scaler.transform(train_set.hour.values.reshape(-1, 1))

test_set.hour = scaler.transform(test_set.hour.values.reshape(-1, 1))

X_train, y_train = train_set.drop(columns=['y']), train_set.y
X_test, y_test = test_set.drop(columns=['y']), test_set.y

X_test['weekday_4'] = 0

X_test['weekday_5'] = 0

from sklearn.ensemble import GradientBoostingRegressor

reg_model = GradientBoostingRegressor(
    n_estimators=300
).fit(X_train, y_train)

reg_model.score(X_train, y_train)

reg_model.score(X_test, y_test)

plt.figure(figsize=(20, 6))

plt.plot(y_test, label="test")
plt.plot(
    pd.DataFrame(reg_model.predict(X_test), index=y_test.index), 
    label="predictions")
plt.legend()

plt.figure(figsize=(20, 6))
plt.plot(y_train, label="test")
plt.plot(
    pd.DataFrame(reg_model.predict(X_train), index=y_train.index), 
    label="predictions")
plt.legend()